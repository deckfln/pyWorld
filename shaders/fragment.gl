varying vec2 vUv;
varying float z;
varying vec3 vertexNormal;

// chunk(packing)
const float PackUpscale = 256. / 255.;
const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
float unpackRGBAToDepth( const in vec4 v ) {
    return dot( v, UnpackFactors );
}
// chunk(packing)

// chunk(shadowmap_pars_fragment);
#ifdef USE_SHADOWMAP
uniform sampler2D directionalShadowMap;
uniform vec2 directionalShadowSize;
varying vec4 vDirectionalShadowCoord;
float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
    float depth = unpackRGBAToDepth( texture2D( depths, uv ) );
    float distance = compare - depth;
    if (distance < 0)
        return 1.0;

    float shadow = distance*20.0;
    return shadow;
}

float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
    float shadow = 1.0;
    shadowCoord.xyz /= shadowCoord.w;
    shadowCoord.z += shadowBias;
    bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
    bool inFrustum = all( inFrustumVec );
    bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
    bool frustumTest = all( frustumTestVec );
    if ( frustumTest ) {
//        shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
        vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
        float dx0 = - texelSize.x * shadowRadius;
        float dy0 = - texelSize.y * shadowRadius;
        float dx1 = + texelSize.x * shadowRadius;
        float dy1 = + texelSize.y * shadowRadius;
        shadow = (
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
                ) * ( 1.0 / 9.0 );
    }
    return shadow;
}
// chunk(shadowmap_pars_fragment);

/**
 * Get the shadow
 */
float getShadowMap()
{
    return  getShadow( directionalShadowMap, directionalShadowSize, 0.0, 0.5, vDirectionalShadowCoord );
}
#endif

uniform sampler2D textures[ 14 ];
uniform sampler2D indexmap;
uniform sampler2D shadowmap;
uniform float indexmap_repeat;
uniform float indexmap_size;
uniform float water_shift;
uniform vec3 light;
uniform float blendmap_repeat;

// textures table
#define blend_png 0
#define water_png 1
#define riverbed_png 2
#define grass_png 3
#define grass1_png 4
#define grass2_png 5
#define forest_png 6
#define forest1_png 7
#define forest2_png 8
#define paving_png 9
#define rock_png 10
#define dirt_png 11
#define dirt1_png 12
#define stone_path_png 13

/**
 * get the texel value from the indexed tile ID at current position vv
 */
vec4 getIndex(int id, vec2 vv)
{
    vec4 texel;

    if (id==blend_png)
          texel=texture2D(textures[blend_png],vv);
    else if (id==water_png)
          texel=texture2D(textures[water_png],vv);
    else if (id==riverbed_png)
          texel=texture2D(textures[riverbed_png],vv);
    else if (id==paving_png)
          texel=texture2D(textures[paving_png],vv);
    else if (id==grass_png)
          texel=texture2D(textures[grass_png],vv);
    else if (id==grass1_png)
          texel=texture2D(textures[grass1_png],vv);
    else if (id==grass2_png)
          texel=texture2D(textures[grass2_png],vv);
    else if (id==forest_png)
          texel=texture2D(textures[forest_png],vv);
    else if (id==forest1_png)
          texel=texture2D(textures[forest1_png],vv);
    else if (id==forest2_png)
          texel=texture2D(textures[forest2_png],vv);
    else if (id==forest2_png)
          texel=texture2D(textures[forest2_png],vv);
    else if (id==rock_png)
          texel=texture2D(textures[rock_png],vv);
    else if (id==dirt_png)
          texel=texture2D(textures[dirt_png],vv);
    else if (id==dirt1_png)
          texel=texture2D(textures[dirt1_png],vv);
    else if (id==stone_path_png)
          texel=texture2D(textures[stone_path_png],vv);

  return texel;
}


/**
 * get the composited texel value at the tile position
 * http://www.iquilezles.org/www/articles/texturerepetition/texturerepetition.htm
 */
vec4 hash4( vec2 p ) { return fract(sin(vec4( 1.0+dot(p,vec2(37.0,17.0)),
                                              2.0+dot(p,vec2(11.0,47.0)),
                                              3.0+dot(p,vec2(41.0,29.0)),
                                              4.0+dot(p,vec2(23.0,31.0))))*103.0); }

vec4 colorAt(vec2 dtile)
{
  vec2 p = dtile/indexmap_size;

  vec2 rvv =  vUv*indexmap_repeat;
  vec4 tile = texture2D(indexmap, p);

  vec2 vv = fract(rvv);

  vec2 iuv = floor(rvv);
  vec4 ofa = hash4(iuv + vec2(0,0));
  vec4 ofb = hash4(iuv + vec2(1,0));
  vec4 ofc = hash4(iuv + vec2(0,1));
  vec4 ofd = hash4(iuv + vec2(1,1));

  ofa.zw = sign(ofa.zw-0.5);
  ofb.zw = sign(ofb.zw-0.5);
  ofc.zw = sign(ofc.zw-0.5);
  ofd.zw = sign(ofd.zw-0.5);

  vec2 b = smoothstep(0.25,0.75,vv);

  vec2 uva = rvv*ofa.zw + ofa.xy;
  vec2 uvb = rvv*ofb.zw + ofb.xy;
  vec2 uvc = rvv*ofc.zw + ofc.xy;
  vec2 uvd = rvv*ofd.zw + ofd.xy;

  int tileID = int(tile.r*255.0);

  return mix( mix( getIndex(tileID, uva), getIndex(tileID, uvb), b.x ),
              mix( getIndex(tileID, uvc), getIndex(tileID, uvb), b.x),
              b.y );

  // first layer tile index
  tileID = int(tile.r*255.0);
  vec4 primary = getIndex(tileID, vv);

  // second layer tile index
  tileID = int(tile.g*255.0);
  vec2 uvv = vec2(vv.y-0.1, vv.x+0.2)*2.0;
  vec4 secondary = getIndex(tileID, uvv);

//  return mix(primary, secondary, tile.a);
  return mix(primary, secondary, 0.5);
}

void main()
{
    /*
//     * if config.terrain.debug_flatness

    gl_FragColor.r = texture2D(indexmap, vUv).r*10.0;
    gl_FragColor.g = 0.0;
    gl_FragColor.b = 0.0;
    gl_FragColor.a = 1.0;

        return;
        */
    // position in the atlasmap
    vec2 mapvUv = vUv*indexmap_size;
    vec2 center_of_tile = floor(mapvUv) + 0.5;
    vec2 delta = fract(mapvUv)-0.5;

    // get a box in the atlas map
    vec2 bottomleft;
    vec2 quadrant = sign(delta);
    bottomleft = clamp(quadrant, vec2(-1, -1), vec2(0, 0));

    // texture from atlas maps at each corner of the box
    bottomleft = center_of_tile + bottomleft;
    vec4 bottomleft_c = colorAt(bottomleft);
    vec4 bottomright_c= colorAt(bottomleft+vec2(1,0));
    vec4 topleft_c= colorAt(bottomleft+vec2(0,1));
    vec4 topright_c= colorAt(bottomleft+vec2(1,1));

    // bilinear blending of the 4 textures
    vec4 bottomleft_b = vec4(0.0, 0.0, 0.0, 1.0);
    vec4 bottomright_b = vec4(0.0, 0.0, 1.0, 0.0);
    vec4 topleft_b = vec4(0.0, 1.0, 0.0, 0.0);
    vec4 topright_b = vec4(1.0, 0.0, 0.0, 0.0);

    // locate the texel inside the quadrand
    vec2 blend4tex = mapvUv - bottomleft;
    vec4 t1 = mix(bottomleft_b, bottomright_b, blend4tex.x);
    vec4 t2 = mix(topleft_b, topright_b, blend4tex.x);
    vec4 t3 = mix(t1, t2, blend4tex.y);

    // blend the 4 quadrand textures
    vec4 ground = t3.w*bottomleft_c + t3.z*bottomright_c + t3.y*topleft_c + t3.x*topright_c;

    // path & river extracted from the blendmap
    vec2 blend_uv = fract(vUv * blendmap_repeat);
    vec4 paving = texture2D(textures[stone_path_png], blend_uv);
    vec4 riverbed = texture2D(textures[riverbed_png], blend_uv);

    vec4 blendIndex = texture2D(textures[blend_png], vUv);
    vec4 red=vec4(1.0, 0.0, 0.0, 1.0);

    vec4 fromBlend = paving*blendIndex.x + red*blendIndex.y + riverbed*blendIndex.z;
    float blend_idx = clamp(blendIndex.x + blendIndex.z, 0.0, 1.0);

    // Add directional light
    vec3 nlight = normalize(light);
    float nDotl = dot(vertexNormal, nlight);
    float brightness = max(nDotl, 0.0);
    vec4 diffuse = vec4(1.0) * brightness;

#ifdef USE_SHADOWMAP
    // extract the shadow
    float shadow = clamp(getShadowMap(), 0.0, 1.0);

//    gl_FragColor = vec4(shadow, 0.0, 0.0, 1.0);

    gl_FragColor = shadow * diffuse*( mix(ground, fromBlend, blend_idx));
#else
    gl_FragColor = diffuse*( mix(ground, fromBlend, blend_idx));
#endif

    // for debug, tint the pixel with the indexmap first value
//    gl_FragColor.r *= (texture2D(indexmap, vUv).g*50.0);

    // debug indexmap
    /*
    gl_FragColor.r = texture2D(indexmap, vUv).r;
    if (int(gl_FragColor.r * 255.0)==grass_png) {
        gl_FragColor.r = 1.0;
    }
    else {
        gl_FragColor.r = 0.25;
    }
    gl_FragColor.g = 0.0;
    gl_FragColor.b = 0.0;
    gl_FragColor.a = 1.0;
    */

    // debug shadowmap
    //    gl_FragColor = texture2D(shadowmap, vUv);
}
